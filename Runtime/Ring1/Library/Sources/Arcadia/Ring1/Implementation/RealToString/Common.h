
#include "Arcadia/Ring1/Implementation/Boolean.h"
#include "Arcadia/Ring1/Implementation/Integer8.h"
#include "Arcadia/Ring1/Implementation/Integer32.h"
#include "Arcadia/Ring1/Implementation/Integer64.h"
#include "Arcadia/Ring1/Implementation/safeMultiply.h"
#include "Arcadia/Ring1/Implementation/Thread.h"
#include "Arcadia/Ring1/Implementation/Natural8.h"
#include "Arcadia/Ring1/Implementation/Natural32.h"
#include "Arcadia/Ring1/Implementation/Natural64.h"
#include "Arcadia/Ring1/Implementation/Numerics/isDivisibleByPowerOfFive.h"
#include "Arcadia/Ring1/Implementation/Process.h"
#include <assert.h>

static Arcadia_Natural8Value nanString[] = u8"<not a number>";
static Arcadia_Natural8Value positiveInfinityString[] = u8"<positive infinity>";
static Arcadia_Natural8Value negativeInfinityString[] = u8"<negative infinity>";
static Arcadia_Natural8Value positiveZero[] = u8"+0";
static Arcadia_Natural8Value negativeZero[] = u8"-0";

// A table of all two-digit numbers. This is used to speed up decimal digit
// generation by copying pairs of digits into the final output.
static const char DIGIT_TABLE[200] = {
  '0','0','0','1','0','2','0','3','0','4','0','5','0','6','0','7','0','8','0','9',
  '1','0','1','1','1','2','1','3','1','4','1','5','1','6','1','7','1','8','1','9',
  '2','0','2','1','2','2','2','3','2','4','2','5','2','6','2','7','2','8','2','9',
  '3','0','3','1','3','2','3','3','3','4','3','5','3','6','3','7','3','8','3','9',
  '4','0','4','1','4','2','4','3','4','4','4','5','4','6','4','7','4','8','4','9',
  '5','0','5','1','5','2','5','3','5','4','5','5','5','6','5','7','5','8','5','9',
  '6','0','6','1','6','2','6','3','6','4','6','5','6','6','6','7','6','8','6','9',
  '7','0','7','1','7','2','7','3','7','4','7','5','7','6','7','7','7','8','7','9',
  '8','0','8','1','8','2','8','3','8','4','8','5','8','6','8','7','8','8','8','9',
  '9','0','9','1','9','2','9','3','9','4','9','5','9','6','9','7','9','8','9','9'
};

// Returns floor(log_10(2^e)); requires 0 <= e <= 1650.
static inline uint32_t
log10Pow2
  (
    const int32_t e
  )
{
  // The first value this approximation fails for is 2^1651 which is just greater than 10^297.
  assert(e >= 0);
  assert(e <= 1650);
  return (((uint32_t)e) * 78913) >> 18;
}

// Returns floor(log_10(5^e)); requires 0 <= e <= 2620.
static inline uint32_t
log10Pow5
  (
    const int32_t e
  )
{
  // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.
  assert(e >= 0);
  assert(e <= 2620);
  return (((uint32_t)e) * 732923) >> 20;
}

// Returns e == 0 ? 1 : ceil(log_2(5^e)); requires 0 <= e <= 3528.
static inline int32_t
pow5bits
  (
    const int32_t e
  )
{
  // This approximation works up to the point that the multiplication overflows at e = 3529.
  // If the multiplication were done in 64 bits, it would fail at 5^4004 which is just greater
  // than 2^9297.
  assert(e >= 0);
  assert(e <= 3528);
  return (int32_t)(((((uint32_t)e) * 1217359) >> 19) + 1);
}

static inline uint64_t
shiftRight128
  (
    Arcadia_Thread* thread,
    const uint64_t lo,
    const uint64_t hi,
      const uint32_t dist
  )
{
  // We don't need to handle the case dist >= 64 here (see above).
  assert(dist < 64);
  assert(dist > 0);
  return (hi << (64 - dist)) | (lo >> dist);
}

static inline uint64_t
mulShift64
  (
    Arcadia_Thread* thread,
    const uint64_t m,
    const uint64_t* const mul,  
    const int32_t j
  )
{
  // m is maximum 55 bits
  uint64_t high1, low1;
  Arcadia_safeMultiplyNatural64Value(thread, m, mul[1], &high1, &low1);
  uint64_t high0;
  Arcadia_safeMultiplyNatural64Value(thread, m, mul[0], &high0, NULL);
  const uint64_t sum = high0 + low1;
  if (sum < high0) {
    ++high1; // overflow into high1
  }
  return shiftRight128(thread, sum, high1, j - 64);
}

static inline uint64_t
mulShiftAll64
  (
    Arcadia_Thread* thread,
    const uint64_t m,
    const uint64_t* const mul,
    const int32_t j,
    uint64_t* const vp,
    uint64_t* const vm,
    const uint32_t mmShift
  )
{
  *vp = mulShift64(thread, 4 * m + 2, mul, j);
  *vm = mulShift64(thread, 4 * m - 1 - mmShift, mul, j);
  return mulShift64(thread, 4 * m, mul, j);
}

// On 32-bit platforms, compilers typically generate calls to library
// functions for 64-bit divisions, even if the divisor is a constant.
//
// E.g.:
// https://bugs.llvm.org/show_bug.cgi?id=37932
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
//
// The functions here perform division-by-constant using multiplications
// in the same way as 64-bit compilers would do.
//
// The multipliers and shift values are the ones generated by clang x64 for expressions like x/5, x/10, etc.
static inline uint64_t
div5
  (
    Arcadia_Thread* thread,
    const uint64_t x
  )
{
  Arcadia_Natural64Value hi;
  Arcadia_safeMultiplyNatural64Value(thread, x, 0xCCCCCCCCCCCCCCCDu, &hi, NULL);
  return hi >> 2;
}

// On 32-bit platforms, compilers typically generate calls to library
// functions for 64-bit divisions, even if the divisor is a constant.
//
// E.g.:
// https://bugs.llvm.org/show_bug.cgi?id=37932
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
//
// The functions here perform division-by-constant using multiplications
// in the same way as 64-bit compilers would do.
//
// The multipliers and shift values are the ones generated by clang x64 for expressions like x/5, x/10, etc.
static inline uint64_t
div10
  (
    Arcadia_Thread* thread,
    const uint64_t x
  )
{
  Arcadia_Natural64Value hi;
  Arcadia_safeMultiplyNatural64Value(thread, x, 0xCCCCCCCCCCCCCCCDu, &hi, NULL);
  return hi >> 3;
}

// On 32-bit platforms, compilers typically generate calls to library
// functions for 64-bit divisions, even if the divisor is a constant.
//
// E.g.:
// https://bugs.llvm.org/show_bug.cgi?id=37932
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
//
// The functions here perform division-by-constant using multiplications
// in the same way as 64-bit compilers would do.
//
// The multipliers and shift values are the ones generated by clang x64 for expressions like x/5, x/10, etc.
static inline uint64_t
div100
  (
    Arcadia_Thread* thread,
    const uint64_t x
  )
{
  Arcadia_Natural64Value hi;
  Arcadia_safeMultiplyNatural64Value(thread, x >> 2, 0x28F5C28F5C28F5C3u, &hi, NULL);
  return hi >> 2;
}

// On 32-bit platforms, compilers typically generate calls to library
// functions for 64-bit divisions, even if the divisor is a constant.
//
// E.g.:
// https://bugs.llvm.org/show_bug.cgi?id=37932
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
//
// The functions here perform division-by-constant using multiplications
// in the same way as 64-bit compilers would do.
//
// The multipliers and shift values are the ones generated by clang x64 for expressions like x/5, x/10, etc.
static inline uint64_t
div1e8
  (
    Arcadia_Thread* thread,
    const uint64_t x
  )
{
  Arcadia_Natural64Value hi;
  Arcadia_safeMultiplyNatural64Value(thread, x, 0xABCC77118461CEFDu, &hi, NULL);
  return hi >> 26;
}

// On 32-bit platforms, compilers typically generate calls to library
// functions for 64-bit divisions, even if the divisor is a constant.
//
// E.g.:
// https://bugs.llvm.org/show_bug.cgi?id=37932
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
//
// The functions here perform division-by-constant using multiplications
// in the same way as 64-bit compilers would do.
//
// The multipliers and shift values are the ones generated by clang x64 for expressions like x/5, x/10, etc.
static inline uint64_t
div1e9
  (
    Arcadia_Thread* thread,
    const uint64_t x
  )
{
  Arcadia_Natural64Value hi;
  Arcadia_safeMultiplyNatural64Value(thread, x >> 9, 0x44B82FA09B5A53u, &hi, NULL);
  return hi >> 11;
}

// Returns true if value is divisible by 2^p without rest (that is, if value is a power of two).
// In particular returns false if value is 0.
static inline bool
Natural64_isMultipleOfPowerOf2
  (
    Arcadia_Thread* thread,
    const uint64_t v,
    const uint32_t p
  )
{
  if (v == 0 || p >= 64) {
    return false;
  }
  assert(v != 0);
  assert(p < 64);
  // __builtin_ctzll doesn't appear to be faster here.
  return (v & ((Arcadia_Natural64Value_Literal(1) << p) - 1)) == 0;
}

// Returns true if value is divisible by 2^p without rest (that is, if value is a power of two).
// In particular returns false if value is 0.
static inline bool
Natural32_multipleOfPowerOf2
  (
    Arcadia_Thread* thread,
    const uint32_t v,
    const uint32_t p
  )
{
  if (v == 0 || p >= 32) {
    return false;
  }
  assert(v != 0);
  assert(p < 32);
  // __builtin_ctz doesn't appear to be faster here.
  return (v & ((Arcadia_Natural32Value_Literal(1) << p) - 1)) == 0;
}
