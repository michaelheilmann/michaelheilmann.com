<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Michael Heilmann's Runtime Mark 1</title>
    <link rel="canonical" href="https://michaelheilmann.com/repository/r1/" />
    <link rel="icon" type="image/x-icon" href="https://michaelheilmann.com/assets/favicon/512x512.svg">
    <link rel="mask-icon" href="https://michaelheilmann.com/assets/favicon/safari-mask-icon-512x512.svg" color="#000000"> <!-- Safari crap. Single color with transparent background. -->
    <link rel="apple-touch-icon" href="https://michaelheilmann.com/assets/favicon/apple-touch-icon-180x180.png" > <!-- iOS crap. 180 * 180px. color attribute is obsolete. -->
    <style>
    body {
      margin: 16px;
    }

    /* variable */
    my-v {
      display: inline;
      font-family: monospace;
    }

    /* meta variable */
    my-mv {
      display: inline;
      font-family: monospace;
    }
    my-mv::before {
      content: "<";
    }
    my-mv::after {
      content: ">";
    }

    /* meta variable */
    .meta {
      font-family: monospace;
    }
    .meta::before {
      content: "<";
    }
    .meta::after {
      content: ">";
    }
    </style>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
  <h1>Michael Heilmann's Runtime Mark 1</h1>
  <p>
  This is the documentation for Michael  Heilmann's Runtime Mark 1,
  henceforth R1. R1 facilates the creation of C programs - in particular interpreters - that are portable,
  maintainable, as well as safe. R1 is available at <a href="https://michaelheilmann.com/repository/r1">michaelheilmann.com/repository/r1</a>.
  <h2>Files</h2>
  <p>You can download/view the sources files of R1 here</p>
  <ul>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/boolean.h">sources/r/boolean.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/clamp.h">sources/r/clamp.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/integer16.h">sources/r/integer16.h</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/integer32.h">sources/r/integer32.h</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/integer64.h">sources/r/integer64.h</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/integer8.h">sources/r/integer8.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/jumptarget.c">sources/r/jumptarget.c</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/jumptarget.h">sources/r/jumptarget.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/maximum.h">sources/r/maximum.h</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/minimum.h">sources/r/minimum.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/natural16.h">sources/r/natural16.h</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/natural32.h">sources/r/natural32.h</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/natural64.h">sources/r/natural64.h</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/natural8.h">sources/r/natural8.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/objectreference.h">sources/r/objectreference.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r.c">sources/r.c</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r.h">sources/r.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/void.h">sources/r/size.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/status.c">sources/r/status.c</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/status.h">sources/r/status.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/value.c">sources/r/value.c</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/value.h">sources/r/value.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/r/void.h">sources/r/void.h</a></li>

    <li><a href="https://michaelheilmann.com/repository/r1/sources/CMakeLists.txt">sources/CMakeLists.txt</a></li>
  </ul>
  <h2>Further references</h2>
  <p>There is a demo available showing-off how to use R1</p>
  <ul>
    <li><a href="https://michaelheilmann.com/repository/r1/demos/helloworld/configure.h.i">demos/r1/demos/helloworld/configure.h.i</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/demos/helloworld/main.c">demos/r1/demos/helloworld/main.c</a></li>
    <li><a href="https://michaelheilmann.com/repository/r1/demos/helloworld/CMakeLists.txt">demos/r1/demos/helloworld/CMakeLists.txt</a></li>
  </ul>
  <p>
  which compiles and runs under various platforms (including but not restricted to Windows, Linux, and many more).
  To build the demo, simply download the files of the demo to some directory (called the demo directory).
  Download the files of <a href="https://michaelheilmann.com/repository/arms1">ARMS1</a> to a directory (called the ARMS1 directory).
  Download the files of R1 to a directory (called the R1 directory).
  Invoke from the demo directory</p>
  <p><code>
  cmake -R1-Source-Dir=<my-mv>r1 source directory</my-mv> -DArms1-Source-Dir=<my-mv>arms1 source directory</my-mv> .
  </code></p>
  <p>where</p>
  <ul>
    <li><my-mv>r1 source directory</my-mv> is the path to the R1 directory</li>
    <li><my-mv>arms1 source directory</my-mv> is the path to a the ARMS1 directory</li>
  </ul>
  <p>Note that relative paths are interpreted relative to <code>${CMAKE_CURRENT_BINARY_DIR}</code>.</p>
  <h2>Documentation</h2>
<h3 id="boolean-type">Boolean Type</h3>
<p>
R1 provides a boolean type.
</p>
<p><code>
typedef <my-mv>implementation detail</my-mv> R_BooleanValue
</code></p>

<p><code>
#define R_BooleanValue_True <my-mv>implementation detail</my-mv>
</code><p>
<p>is a value of the type denoting logically <code>true</code>. It converts to <code>1</code> in arithmetic expressions.</p>

<p><code>
#define R_BooleanValue_False <my-mv>implementation detail</my-mv>
</code><p>
<p>is a value of the type denoting logically <code>false</code>. It converts to <code>0</code> in arithmetic expressions.</p>
<h3 id="integer-types">Integer Types</h3>
<p>
R provides a two's complement integer number types.
</p>
<p><code>
typedef <my-mv>implementation detail</my-mv> R_Integer<my-mv>Suffix</my-mv>Value
</code></p>
<p>
where <my-mv>Suffix</my-mv> denotes the number of Bits of the two's complement integer and can be one of
<code>8</code>, <code>16</code>, <code>32</code>, or <code>64</code>.
</p>

<p>The macros in this section all include the <my-mv>Suffix</my-mv> metavariable and are defined for the
values <code>8</code>, <code>16</code>, <code>32</code>, and <code>64</code> of that meta variable.</p>

<p><code>
#define R_Integer<my-mv>Suffix</my-mv>Value_NumberOfBits <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bits of the type. The value is always equal to the value of the respective <my-mv>Suffix</my-mv>.</p>

<p><code>
#define R_Integer<my-mv>Suffix</my-mv>Value_NumberOfBytes <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bytes of the type which is usually <code>R_Integer<my-mv>Suffix</my-mv>Value_NumberOfBits</code> divided by 8.</p>

<p><code>
#define R_Integer<my-mv>Suffix</my-mv>Value_Minimum <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the least value (in terms of its magnitude) representable by a the <code>R_Integer<my-mv>Suffix</my-mv>Value</code> type.
The following table denotes the value of the constant for the respective <my-mv>Suffix</my-mv>
</p>
<table>
<tr><td><my-mv>Suffix</my-mv></td><td>Value</td></tr>
<tr><td>8                    </td><td>-128</td></tr>
<tr><td>16                   </td><td>-32768</td></tr>
<tr><td>32                   </td><td>-2147483648</td></tr>
<tr><td>64                   </td><td>-9223372036854775808</td></tr>
</table>

<p><code>
#define R_Integer<my-mv>Suffix</my-mv>Value_Maximum <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the greatest value (in terms of its magnitude) representable by a the <code>R_Integer<my-mv>Suffix</my-mv>Value</code> type.
The following table denotes the value of the constant for the respective <my-mv>Suffix</my-mv>
</p>
<table>
<tr><td><my-mv>Suffix</my-mv></td><td>Value</td></tr>
<tr><td>8                    </td><td>127</td></tr>
<tr><td>16                   </td><td>32767</td></tr>
<tr><td>32                   </td><td>2147483647</td></tr>
<tr><td>64                   </td><td>9223372036854775807</td></tr>
</table>

<p><code>
#define R_Integer<my-mv>Suffix</my-mv>Value_Literal(x) <my-mv>implementation detail</my-mv>
</code><p>
<p>is used to write a literal of the type <code>R_Integer<my-mv>Suffix</my-mv></code> in C source code.
The following table denotes  the expansions of the macro:
</p>
<table>
<tr><td><my-mv>Suffix</my-mv></td><td>Value</td></tr>
<tr><td>8                    </td><td>x</td></tr>
<tr><td>16                   </td><td>x</td></tr>
<tr><td>32                   </td><td>x</td></tr>
<tr><td>64                   </td><td>x##LL</td></tr>
</table>
<h3 id="natural-types">Natural Types</h3>
<p>
R provides natural number types.
</p>
<p><code>
typedef <my-mv>implementation detail</my-mv> R_Natural<my-mv>Suffix</my-mv>Value
</code></p>
<p>
where <my-mv>Suffix</my-mv> denotes the number of Bits of the integer and can be one of
<code>8</code>, <code>16</code>, <code>32</code>, or <code>64</code>.
</p>

<p>The macros in this section all include the <my-mv>Suffix</my-mv> metavariable and are defined for the
values <code>8</code>, <code>16</code>, <code>32</code>, and <code>64</code> of that meta variable.</p>

<p><code>
#define R_Natural<my-mv>Suffix</my-mv>Value_NumberOfBits <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bits of the type. The value is always equal to the value of the respective <my-mv>Suffix</my-mv>.</p>

<p><code>
#define R_Integer<my-mv>Suffix</my-mv>Value_NumberOfBytes <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bytes of the type which is usually <code>R_Integer<my-mv>Suffix</my-mv>Value_NumberOfBits</code> divided by 8.</p>

<p><code>
#define R_Natural<my-mv>Suffix</my-mv>Value_Minimum <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the least value (in terms of its magnitude) representable by a the <code>R_Natural<my-mv>Suffix</my-mv>Value</code> type.
The following table denotes the value of the constant for the respective <code><my-mv>Suffix</my-mv></code>
</p>
<table>
<tr><td><my-mv>Suffix</my-mv></td><td>Value</td></tr>
<tr><td>8                    </td><td>0</td></tr>
<tr><td>16                   </td><td>0</td></tr>
<tr><td>32                   </td><td>0</td></tr>
<tr><td>64                   </td><td>0</td></tr>
</table>

<p><code>
#define R_Natural<my-mv>Suffix</my-mv>Value_Maximum <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the greatest value (in terms of its magnitude) representable by a the <code>R_Natural<span>Suffix</span>Value</code> type.
The following table denotes the value of the constant for the respective <code><span>Suffix</span></code>
</p>
<table>
<tr><td><code><span>Constant</span></code></td><td>Value</td></tr>
<tr><td>8                                  </td><td>255</td></tr>
<tr><td>16                                 </td><td>65535</td></tr>
<tr><td>32                                 </td><td>4294967295</td></tr>
<tr><td>64                                 </td><td>18446744073709551615</td></tr>
</table>

<p><code>
#define R_Natual<my-mv>Suffix</my-mv>Value_Literal(x) <my-mv>implementation detail</my-mv>
</code><p>
<p>is used to write a literal of the type <code>R_Natural<my-mv>Suffix</my-mv></code> in C source code.
The following table denotes  the expansions of the macro:
</p>
<table>
<tr><td><my-mv>Suffix</my-mv></td><td>Value</td></tr>
<tr><td>8                    </td><td>x</td></tr>
<tr><td>16                   </td><td>x</td></tr>
<tr><td>32                   </td><td>x##U</td></tr>
<tr><td>64                   </td><td>x##ULL</td></tr>
</table>
<h3 id="size-type">Size Type</h3>
<p>
R provides an alias for builtin <code>size_t</code> type.
</p>
<p><code>
typedef <my-mv>implementation detail</my-mv> R_SizeValue
</code></p>

<p><code>
#define R_SizeValue_NumberOfBits <my-mv>implementation detail</my-mv>
</code><p>
<p>
denotes the number of Bits of the type.
<b>
This number must one of 32 or 64, otherwise the environment is not supported by R.
This restriction may be relaxed in future versions of R.
</b></p>

<p><code>
#define R_SizeValue_NumberOfBytes <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bytes of the type which is usually <code>R_SizeValue_NumberOfBits</code> divided by 8.</p>

<p><code>
#define R_SizeValue_Minimum <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the least value (in terms of its magnitude) representable by a the <code>R_Size</code> type.</p>

<p><code>
#define R_SizeValue_Literal(x) <my-mv>implementation detail</my-mv>
</code><p>
<p>is used to write a literal of type <code>R_SizeValue</code> in C source code.</p>
<h3 id="void-type">Void Type</h3>
<p>
R provides a void type.
</p>
<p><code>
typedef <my-mv>implementation detail</my-mv> R_VoidValue
</code></p>
<p>
The only value of this type is <code>R_VoidValue_Void</code>.
R_VoidValue is an unsigned integral type.
</p>

<p><code>
#define R_VoidValue_Void <my-mv>implementation detail</my-mv>
</code><p>
<p>The single value of the type.</p>

<p><code>
#define R_VoidValue_NumberOfBits <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bits of the type.</p>

<p><code>
#define R_VoidValue_NumberOfBytes <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bytes of the type which is usually <code>R_VoidValue_NumberOfBits</code> divided by 8.</p>
<h3 id="object-reference-type">Object Reference Type</h3>
<p>
R provides a ObjectReference type.
</p>
<p><code>
typedef <my-mv>implementation detail</my-mv> R_ObjectReferenceValue
</code></p>
<p>
The <code>R_ObjectReferenceValue</code> type is a pointer.
</p>

<p>
A valid value of the <code>R_ObjectReferenceValue</code> is the null reference
</p>
<p><code>
#define R_ObjectReferenceValue_Null <my-mv>implementation detail</my-mv>
</code></p>

<p><code>
#define R_ObjectReferenceValue_NumberOfBits <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bits of the type.</p>

<p><code>
#define R_ObjectReferenceValue_NumberOfBytes <my-mv>implementation detail</my-mv>
</code><p>
<p>denotes the number of Bytes of the type which is usually <code>R_ObjectReferenceValue_NumberOfBits</code> divided by 8.</p>
<h3 id="value-type">Value Type</h3>
<p>
<code>R_Value</code> is a tagged union of values supported by the
runtime. It consists of a tag indicating the value stored in the
union and the union of the values. The following table lists all
possible tags and their corresponding type.
</p>
<table>
  <tr><td>Tag                       </td><td>Type                  </td></tr>

  <tr><td>R_ValueTag_Boolean        </td><td>R_BooleanValue        </td></tr>

  <tr><td>R_ValueTag_Integer16      </td><td>R_Integer16Value      </td></tr>
  <tr><td>R_ValueTag_Integer32      </td><td>R_Integer32Value      </td></tr>
  <tr><td>R_ValueTag_Integer64      </td><td>R_Integer64Value      </td></tr>
  <tr><td>R_ValueTag_Integer8       </td><td>R_Integer8Value       </td></tr>

  <tr><td>R_ValueTag_Natural16      </td><td>R_Natural16Value      </td></tr>
  <tr><td>R_ValueTag_Natural32      </td><td>R_Natural32Value      </td></tr>
  <tr><td>R_ValueTag_Natural64      </td><td>R_Natural64Value      </td></tr>
  <tr><td>R_ValueTag_Natural8       </td><td>R_Natural8Value       </td></tr>

  <tr><td>R_ValueTag_ObjectReference</td><td>R_ObjectReferenceValue</td></tr>

  <tr><td>R_ValueTag_Size           </td><td>R_SizeValue           </td></tr>

  <tr><td>R_ValueTag_Void           </td><td>R_VoidValue           </td></tr>
</table>

<p>
For each type, <code>R_Value</code> has three functions associated:
</p>
<p><code>
<my-mv>Type</my-mv> R_Value_get<my-mv>Suffix</my-mv>(R_Value const* value)<br>
bool R_Value_is<my-mv>Suffix</my-mv>(R_Value const* value)<br>
void R_Value_set<my-mv>Suffix</my-mv>(R_Value* value, R_<my-mv>Suffix</my-mv>Value <my-mv>Variable</my-mv>Value)
</code></p>
<p>The following table lists the valid combinations of <my-mv>Suffix</my-mv> and <my-mv>Variable</my-mv></p>

<table>
  <tr><td>Boolean        </td><td>boolean        </td></tr>

  <tr><td>Integer16      </td><td>integer16      </td></tr>
  <tr><td>Integer32      </td><td>integer32      </td></tr>
  <tr><td>Integer64      </td><td>integer64      </td></tr>
  <tr><td>Integer8       </td><td>integer8       </td></tr>

  <tr><td>Natural16      </td><td>natural16      </td></tr>
  <tr><td>Natural32      </td><td>natural32      </td></tr>
  <tr><td>Natural64      </td><td>natural64      </td></tr>
  <tr><td>Natural8       </td><td>natural8       </td></tr>
  
  <tr><td>ObjectReference</td><td>objectReference</td></tr>

  <tr><td>Size           </td><td>size           </td></tr>

  <tr><td>Void           </td><td>void           </td></tr>
</table>

<p><code>R_Value_is<my-mv>Suffix</my-mv></code> returns <code>true</code> if
the <code>R_Value</code> stores a value of the type corresponding to <my-mv>Suffix</my-mv>. Otherwise it returns <code>false</code>.</p>

<p><code>R_Value_set<my-mv>Suffix</my-mv></code> assigns the <code>R_Value</code>
a value of the type corresponding to <my-mv>Suffix</my-mv>.</p>

<p><code>R_Value_get<my-mv>Type</my-mv></code> get the value stored   in
the <code>R_Value</code>. The behavior of <code>R_Value_set<my-mv>Suffix
</my-mv></code> is undefined if the value does not store a value of  the
type corresponding to <my-mv>Suffix</my-mv>.</p>
  <h3 id="status-codes">Status Codes</h3>
  <p>
  R provides a status type and symbolic constants for its values. That type denotes success or failure of program (or a part of it)
  as well as information on the reason for the failure.</p>

  <p><code>
  typedef <my-mv>implementation detail</my-mv> R_Status
  </code></p>
  <p>
  <code>R_Status</code> is a natural number type of a width of 32 Bit.</p>

  <p><code>
  #definer R_Status_Success <my-mv>implementation detail</my-mv>
  </code></p>
  <p>is the symbolic constant of the type <code>R_Status</code> has the value <code>((R_Status)0)</code>.
  It denotes success and is guaranteed to be defined to the value <code>0</code> of the underlaying natural number
  type of R_Status as well as to be the only symbolic constant starting with <code>R_Status_</code> having
  defined to that value.</p>

  <p>
  Symbolic constants of the form
  </p>
  <p><code>
  #definer R_Status_<my-mv>Name</my-mv> <my-mv>implementation detail</my-mv>
  </code></p>
  <p>where <my-mv>Name</my-mv> is not <code>Success</code> provide information on failure of a program (or a part of it).
  The following table denotes the value of the constant for the respective <my-mv>Name</my-mv>
  </p>
  <table>
  <tr><td><code><span>Name</span></code>        </td><td>Value</td></tr>
  <tr><td><code>AllocationFailed</code>         </td><td>An allocation failed.</td></tr>
  <tr><td><code>ArgumentTypeInvalid</code>      </td><td>The type of an argument is invalid.</td></tr>
  <tr><td><code>ArgumentValueInvalid</code>     </td><td>The value of an argument is invalid.</td></tr>
  
  <tr><td><code>EncodingInvalid</code>          </td><td>An encoding is invalid.</td></tr>
  
  <tr><td><code>FileSystemOperationFailed</code></td><td>A file system operation failed.</td></tr>  
  
  
  <tr><td><code>Initialized</code>              </td><td>Something was initialized (but should not have been initialized).</td></tr>
  <tr><td><code>NumberOfArgumentsInvalid</code> </td><td>The number of arguments is invalid.</td></tr>
  <tr><td><code>OperationInvalid</code>         </td><td>An operation is invalid.</td></tr>
  <tr><td><code>TestFailed</code>               </td><td>A test failed. This is used by the built-in tests that ensure correctness.</td></tr>
  <tr><td><code>Uninitialized</code>            </td><td>Something was uninitialized (but should have been initialized).</td></tr>
  </table>
  <h3 id="status-variable">Status Variable</h3>
  <p>R provides a global status variable.</p>

  <p><code>
  R_Status
  R_getStatus
    (
    );
  </code></p>
  <p>gets the value of the status variable. The initial value of the status variable is <code>R_Status_Success</code>.</p>

  <p><code>
  void
  R_setStatus
    (
      R_Status status
    );
  </code></p>
  <p>sets the value of the status variable to the value <code>status</code>.</p>
  <h3>Jumps and Jump Targets</h3>
  <p>R provides non-local jumps by allowing to save and restore the C program state.</p>

  <p><code>
  typedef <my-mv>implementation detail</my-mv> R_JumpTarget;
  </code></p>
  <p>is a type of which its values are stack allocated.</p>

  <p><code>
  void R_pushJumpTarget(R_JumpTarget* jumpTarget);
  </code></p>
  <p>
  Push a jump target on top of the jump target stack.
  Initially, the jump target stack is empty.
  </p>

  <p><code>
  void R_popJumpTarget();
  </code></p>
  <p>
  Pop the jump target on top of the jump target stack.
  The jump target stack must not be empty.
  </p>

  <p><code>
  void R_jump();
  </code></p>
  <p>
  Jump to the jump target on top of the jump target stack.
  The jump target stack must not be empty.
  </p>
  
  <p><code>
  #define R_JumpTarget_save(jumpTarget) <my-mv>implementation detail</my-mv>
  </code></p>
  <p>Macro to save the current C program state into a jump target.</p>
  
  <p>The canonical way of using <code>R_pushJumpTarget</code>, <code>R_popJumpTarget</code>, and
  <code>R_jump</code> is the following.</p>
  <p><code>
  R_pushJumpTarget(&jumpTarget);<br>
  if (R_JumpTarget_save(&jumpTarget)) {<br>
    &nbsp;<my-mv>(1)</my-mv><br>
    &nbsp;R_popJumpTarget();<my-mv>(2)</my-mv><br>
  } else {<br>
    &nbsp;R_popJumpTarget();<my-mv>(3)</my-mv><br>
    &nbsp;<my-mv>(4)</my-mv><br>
  }<br>
  <my-mv>(5)</my-mv>
  </code></p>
  <p>
  The    if-branch is always entered at first as the <code>R_JumpTarget_save()</code>       at
  its first invocation returns logically true. If the program at <my-mv>(1)</my-mv> does   not
  jump to the jump target (using <code>R_jump()</code>),  then <code>R_popJumpTarget();<my-mv>
  (2)</my-mv></code> and <my-mv>(5)</my-mv> are executed. If the program at <my-mv>(1)</my-mv>
  jumps to the jump target, then <code>R_JumpTarget_save()</code> is re-evaluated and  returns
  logically false and <code>R_popJumpTarget();<my-mv>(2)</my-mv></code> and <my-mv>(4)</my-mv>
  is executed.
  </p>
  
  <p>One usage example is the implementation of the <code>R_safeExecute</code> function.</p> 
  <p><code>
  void R_safeExecute(void (*f)()) {<br>
  &nbsp;R_JumpTarget jumpTarget;<br>
  &nbsp;R_pushJumpTarget(&jumpTarget);<br>
  &nbsp;if (R_JumpTarget_save(&jumpTarget)) {<br>
  &nbsp;&nbsp;f();<br>
  &nbsp;&nbsp;R_popJumpTarget();<br>
  &nbsp;}<br>
  }
  </code></p>
<h3>Numeric functions</h3>
<h4>R_clamp</h4>
<p>R provides functions clamping values to a value range.</p>
<p><code>
<my-mv>Type</my-mv> R_clamp_<my-mv>Suffix</my-mv>(<my-mv>Type</my-mv> value, <my-mv>Type</my-mv> lower, <my-mv>Type</my-mv> upper)
</code></p>
<p>The following table lists the combinations of <my-mv>Type</my-mv> and <my-mv>Suffix</my-mv> for which the above functions are defined</p>

<table>
<tr><td><my-mv>Suffix</my-mv></td><td><my-mv>Type</my-mv></td></tr>
<tr><td><code>i8</code>      </td><td><code>R_Integer8Value</code></td></tr>
<tr><td><code>i16</code>     </td><td><code>R_Integer16Value</code></td></tr>
<tr><td><code>i32</code>     </td><td><code>R_Integer32Value</code></td></tr>
<tr><td><code>i64</code>     </td><td><code>R_Integer64Value</code></td></tr>
<tr><td><code>n8</code>      </td><td><code>R_Natural8Value</code></td></tr>
<tr><td><code>n16</code>     </td><td><code>R_Natural16Value</code></td></tr>
<tr><td><code>n32</code>     </td><td><code>R_Natural32Value</code></td></tr>
<tr><td><code>n64</code>     </td><td><code>R_Natural64Value</code></td></tr>
<tr><td><code>sz</code>      </td><td><code>R_Size</code></td></tr>
</table>

<p>This function returns the value <code>value</code> clamped to the range <code>[lower, upper]</code>.
If <code>lower &gt; upper</code> then this function sets the status variable to <code>R_Status_ArgumentValueInvalid</code> and jumps.</p>
<h4>R_countLeadingZeroes</h4>
<p>R provides functions counting the leading zeroes of the binary representations of integer type values, natural type values, and size type values.</p>
<p><code>
R_SizeValue R_countLeadingZeroes_<my-mv>Suffix</my-mv>(<my-mv>Type</my-mv> value)
</code></p>
<p>The following table lists the combinations of <my-mv>Type</my-mv> and <my-mv>Suffix</my-mv> for which the above functions are defined</p>

<table>
<tr><td><my-mv>Suffix</my-mv></td><td><my-mv>Type</my-mv></td></tr>
<tr><td><code>i8</code>      </td><td><code>R_Integer8Value</code></td></tr>
<tr><td><code>i16</code>     </td><td><code>R_Integer16Value</code></td></tr>
<tr><td><code>i32</code>     </td><td><code>R_Integer32Value</code></td></tr>
<tr><td><code>i64</code>     </td><td><code>R_Integer64Value</code></td></tr>
<tr><td><code>n8</code>      </td><td><code>R_Natural8Value</code></td></tr>
<tr><td><code>n16</code>     </td><td><code>R_Natural16Value</code></td></tr>
<tr><td><code>n32</code>     </td><td><code>R_Natural32Value</code></td></tr>
<tr><td><code>n64</code>     </td><td><code>R_Natural64Value</code></td></tr>
<tr><td><code>sz</code>      </td><td><code>R_Size</code></td></tr>
</table>

<p>This function returns the number of leading zeroes of the binary representation of <code>value</code>.</p>
<h4>R_maximum</h4>
<p>R provides functions returning the maximum of two values.</p>
<p><code>
&lt;Type&gt; R_maximum_&lt;Suffix&gt;(&lt;Type&gt; x, &lt;Type&gt;)
</code></p>
<p>The following table lists the combinations of <code>&lt;Type&gt;</code> and <code>&lt;Suffix&gt;</code> for which the above functions are defined</p>

<table>
<tr><td><my-mv>Suffix</my-mv></td><td><my-mv>Type</my-mv></td></tr>
<tr><td><code>i8</code>      </td><td><code>R_Integer8Value</code></td></tr>
<tr><td><code>i16</code>     </td><td><code>R_Integer16Value</code></td></tr>
<tr><td><code>i32</code>     </td><td><code>R_Integer32Value</code></td></tr>
<tr><td><code>i64</code>     </td><td><code>R_Integer64Value</code></td></tr>
<tr><td><code>n8</code>      </td><td><code>R_Natural8Value</code></td></tr>
<tr><td><code>n16</code>     </td><td><code>R_Natural16Value</code></td></tr>
<tr><td><code>n32</code>     </td><td><code>R_Natural32Value</code></td></tr>
<tr><td><code>n64</code>     </td><td><code>R_Natural64Value</code></td></tr>
<tr><td><code>sz</code>      </td><td><code>R_Size</code></td></tr>
</table>
<h4>R_minimum</h4>
<p>R provides functions returning the minimum of two values.</p>
<p><code>
<my-mv>Type</my-mv> R_minimum_<my-mv>Suffix</my-mv>(<my-mv>Type</my-mv> x, <my-mv>Type</my-mv> y)
</code></p>
<p>The following table lists the combinations of <my-mv>Type</my-mv> and <my-mv>Suffix</my-mv> for which the above functions are defined</p>

<table>
<tr><td><my-mv>Suffix</my-mv></td><td><my-mv>Type</my-mv></td></tr>
<tr><td><code>i8</code>      </td><td><code>R_Integer8Value</code></td></tr>
<tr><td><code>i16</code>     </td><td><code>R_Integer16Value</code></td></tr>
<tr><td><code>i32</code>     </td><td><code>R_Integer32Value</code></td></tr>
<tr><td><code>i64</code>     </td><td><code>R_Integer64Value</code></td></tr>
<tr><td><code>n8</code>      </td><td><code>R_Natural8Value</code></td></tr>
<tr><td><code>n16</code>     </td><td><code>R_Natural16Value</code></td></tr>
<tr><td><code>n32</code>     </td><td><code>R_Natural32Value</code></td></tr>
<tr><td><code>n64</code>     </td><td><code>R_Natural64Value</code></td></tr>
<tr><td><code>sz</code>      </td><td><code>R_Size</code></td></tr>
</table>
<h3>Objects</h3>
<h4 id="r-bytebuffer">Byte Buffer</h4>
<p>
<code>R_ByteBuffer</code> represents a mutable sequence of Bytes.
This type is allocated on the heap and values of this type are referenced by <code>R_ByteBuffer</code> pointers.
A <code>R_ByteBuffer</code> pointer can be safely cast into a <code>R_ObjectReferenceValue</code> values.
An <code>R_ObjectReferenceValue</code> pointing to a <code>R_ByteBuffer</code> value can be safely cast into a <code>R_ByteBuffer*</code> pointer.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-create">create</h5>

<p><code>
R_ByteBuffer* R_ByteBuffer_create()
</code></p>

<p>Create an empty Byte buffer.</p>

<h6><b>Return Value</b></h6>
<p>A pointer to the Byte buffer.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-clear">clear</h5>
<p><code>
void R_ByteBuffer_clear(R_ByteBuffer* self)
</code></p>

<p>Set the number of elements of this Byte buffer to zero.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-append-pn">append_pn</h5>
<p><code>
void R_ByteBuffer_append_pn(R_ByteBuffer* self, void const* p, R_SizeValue n)
</code></p>

<p>Append Bytes to this Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>void const* p     </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue n     </td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-prepend-pn">prepend_pn</h5>
<p><code>
void R_ByteBuffer_prepend_pn(R_ByteBuffer* self, void const* p, R_SizeValue n)
</code></p>

<p>Prepend Bytes to this Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>void const* p     </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue n     </td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-insert-pn">insert_pn</h5>
<p><code>
void R_ByteBuffer_insert_pn(R_ByteBuffer* self, R_SizeValue index, void const* p, R_SizeValue n)
</code></p>

<p>Insert Bytes into this Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>R_SizeValue index </td><td>The index at which to insert the Bytes. Must be within the bounds of <code>[0,n)</code> where <code>n</code> is the size of this Byte buffer.</td></tr>
  <tr><td>void const* p     </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue n     </td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-isequalto">isEqualTo</h5>
<p><code>
void R_ByteBuffer_isEqualTo(R_ByteBuffer const* self, R_ByteBuffer const* other)
</code></p>

<p>Compare this Byte buffer with another Byte buffer for equality.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer const* self </td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>R_ByteBuffer const* other</td><td>A pointer to the other Byte buffer.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-getsize">getSize</h5>
<p><code>
R_SizeValue R_ByteBuffer_getSize(R_ByteBuffer const* self)
</code></p>

<p>Get the size of this Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The size of this Byte buffer.</p>

<h6><b>Remarks</b></h6>
<p> The size of a Byte buffer is the length of the Byte sequence it contains.</p>
  <footer style="border-top-style: solid; border-top-width: 1px; margin-top: 16px; padding-top: 16px;">
    <span style="font-style: italic">Webite maintained by Michael Heilmann. Last modified on 27 August 2024.</span>
  </footer>
  </body>
</html>
