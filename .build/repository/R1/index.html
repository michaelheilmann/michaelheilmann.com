<!DOCTYPE html>
<html class='my-theme-1' lang='en'>
<head>

  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>

  <link rel='icon' type='image/x-icon' href='https://michaelheilmann.com/assets/favicon/512x512.svg'>

  <!-- Crap specific to Safari. SVG must be single color with transparent background. -->
  <link rel='mask-icon' href='https://michaelheilmann.com/assets/favicon/safari-mask-icon-512x512.svg' color = '#000000'>

  <!-- Crap specific to iOS. PNG must be 180 x 180 pixels. color attribute is obsolete. -->
  <link rel='apple-touch-icon' href='https://michaelheilmann.com/assets/favicon/apple-touch-icon-180x180.png'>

<link rel='stylesheet' href='https://michaelheilmann.com/assets/reset.css?v=3'>
<link rel='stylesheet' href='https://michaelheilmann.com/assets/index.css?v=3'>
<link rel='canonical' href='https://michaelheilmann.com/repository/R1/'>
<title>Michael Heilmann's Runtime Mark 1</title>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  /* variable */
  my-v {
    font-family: my-code-font;
    font-size: 0.9rem;
  }

  /* meta variable */
  my-mv {
    display: inline;
    font-family: my-code-font;
    font-size: 0.9rem;
  }
  my-mv::before {
    content: "<";
  }
  my-mv::after {
    content: ">";
  }

  /* meta variable */
  .meta {
    font-family: my-code-font;
    font-size: 0.9rem;
  }
  .meta::before {
    content: "<";
  }
  .meta::after {
    content: ">";
  }
</style>
</head>
<body class="my-content-page-1">
  <header>
    <div>
    <a href="https://michaelheilmann.com/">Home</a>
    </div>
  </header>
<main>
  <div class="left-column"></div>
  <div class="center-column">
  <h1>Michael Heilmann's Runtime Mark 1</h1>
  <p>
  This is the documentation for Michael  Heilmann's Runtime Mark 1,
  henceforth R1. R1 facilitates the creation of C programs - in particular interpreters - that are portable,
  maintainable, as well as safe. R1 is available at <a href="https://michaelheilmann.com/repository/R1">michaelheilmann.com/repository/R1</a>.

<h2>1. Files</h2>
<p>
You can find the sources of R1 in my GitHub repository <a href="https://github.com/michaelheilmann/michaelheilmann.com">https://github.com/michaelheilmann/michaelheilmann.com</a>.
The subdirectory of R1 in the repository is here <a href="https://github.com/michaelheilmann/michaelheilmann.com/tree/main/repository/R1">https://github.com/michaelheilmann/michaelheilmann.com/tree/main/repository/R1</a>.</p>
</p>

<ul>
  <li>The (sources of the) library resides in the directory
  <a href="https://github.com/michaelheilmann/michaelheilmann.com/tree/main/repository/R1/Sources">https://github.com/michaelheilmann/michaelheilmann.com/tree/main/repository/R1/Sources</a>
  </li>
  <li>The (sources of) tests reside in the directory
  <a href="https://github.com/michaelheilmann/michaelheilmann.com/tree/main/repository/R1/Tests">https://github.com/michaelheilmann/michaelheilmann.com/tree/main/repository/R1/Tests</a>
  </li>
  <li>The (sources of this very documentation you are reading) documentation reside in the directory
  <a href="https://github.com/michaelheilmann/michaelheilmann.com/tree/main/repository/R1/Documentation">https://github.com/michaelheilmann/michaelheilmann.com/tree/main/repository/R1/Documentation</a>
  </li>
</ul>

<p>
R1 supports various platforms (including but not restricted to Windows, Linux, and many more), however, we currently only officially support Windows.
Find instructions on how to build, test, and use R1 under various systems,
please refer to <a href="https://github.com/michaelheilmann/michaelheilmann.com/tree/main/README.md">README.md</a> in the root folder of the repository.
</p>

<h2>2. Further References</h2>
<p>R1 relies on <a href="https://michaelheilmann.com/repository/Arms1">ARMS1</a> and <a href="https://michaelheilmann.com/repository/Arcadia.Ring1">Arcadia Ring1</a>.</p>

  <h2>3. Documentation</h2>

<h3>3.8. Objects</h3>

<h4 id="r-bytebuffer">Byte Buffer</h4>
<p>
<code>R_ByteBuffer</code> represents a mutable sequence of Bytes.
This type is allocated on the heap and values of this type are referenced by <code>R_ByteBuffer</code> pointers.
A <code>R_ByteBuffer</code> pointer can be safely cast into a <code>R_ObjectReferenceValue</code> values.
An <code>R_ObjectReferenceValue</code> pointing to a <code>R_ByteBuffer</code> value can be safely cast into a <code>R_ByteBuffer</code> pointer.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-create">create</h5>

<p><code>
R_ByteBuffer* R_ByteBuffer_create()
</code></p>

<p>Create an empty Byte buffer.</p>

<h6><b>Return Value</b></h6>
<p>A pointer to the Byte buffer.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-clear">clear</h5>
<p><code>
void R_ByteBuffer_clear(R_ByteBuffer* self)
</code></p>

<p>Set the number of elements of this Byte buffer to zero.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-bytebuffer-endswith-pn">endsWith_pn</h5>
<p><code>
R_BooleanValue R_ByteBuffer_endsWith_pn(R_ByteBuffer const* self, void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Get if a sequence of Bytes is a suffix of this Byte buffer's sequence of Bytes.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self       </td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>void const* bytes        </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
<code>R_BooleanValue_True</code> if the sequence of Bytes is a suffix of this byte buffer's sequence of Bytes.
<code>R_BooleanValue_False</code> otherwise.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-bytebuffer-startswith-pn">startsWith_pn</h5>
<p><code>
R_BooleanValue R_ByteBuffer_startsWith_pn(R_ByteBuffer const* self, void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Get if a sequence of Bytes is a prefix of this Byte buffer's sequence of Bytes.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self       </td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>void const* bytes        </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
<code>R_BooleanValue_True</code> if the sequence of Bytes is a prefix of this byte buffer's sequence of Bytes.
<code>R_BooleanValue_False</code> otherwise.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-bytebuffer-isequalto-pn">isEqualTo_pn</h5>
<p><code>
R_BooleanValue R_ByteBuffer_isEqualTo_pn(R_ByteBuffer const* self, void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Get if a sequence of Bytes is this Byte buffer's sequence of Bytes.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self       </td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>void const* bytes        </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
<code>R_BooleanValue_True</code> if the sequence of Bytes is this byte buffer's sequence of Bytes.
<code>R_BooleanValue_False</code> otherwise.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-append-pn">append_pn</h5>
<p><code>
void R_ByteBuffer_append_pn(R_ByteBuffer* self, void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Append Bytes to this Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self       </td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>void const* bytes        </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>self</code> is a null pointer. </td></tr>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>bytes</code> is a null pointer.</td></tr>
  <tr><td>R_Status_AllocationFailed    </td><td>An allocation failed.                </td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-prepend-pn">prepend_pn</h5>
<p><code>
void R_ByteBuffer_prepend_pn(R_ByteBuffer* self, void const* p, R_SizeValue n)
</code></p>

<p>Prepend Bytes to this Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>void const* p     </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue n     </td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>self</code> is a null pointer. </td></tr>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>bytes</code> is a null pointer.</td></tr>
  <tr><td>R_Status_AllocationFailed    </td><td>An allocation failed.                </td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-insert-pn">insert_pn</h5>
<p><code>
void R_ByteBuffer_insert_pn(R_ByteBuffer* self, R_SizeValue index, void const* p, R_SizeValue n)
</code></p>

<p>Insert Bytes into this Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>R_SizeValue index </td><td>The index at which to insert the Bytes. Must be within the bounds of <code>[0,n)</code> where <code>n</code> is the size of this Byte buffer.</td></tr>
  <tr><td>void const* p     </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue n     </td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>self</code> is a null pointer. </td></tr>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>bytes</code> is a null pointer.</td></tr>
  <tr><td>R_Status_AllocationFailed    </td><td>An allocation failed.                </td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-isequalto">isEqualTo</h5>
<p><code>
R_BooleanValue R_ByteBuffer_isEqualTo(R_ByteBuffer const* self, R_ByteBuffer const* other)
</code></p>

<p>Compare this Byte buffer with another Byte buffer for equality.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer const* self </td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>R_ByteBuffer const* other</td><td>A pointer to the other Byte buffer.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
<code>R_BooleanValue_True</code> if this Byte buffer is equal to the other Byte buffer.
<code>R_BooleanValue_False</code> otherwise.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-getsize">getSize</h5>
<p><code>
R_SizeValue R_ByteBuffer_getSize(R_ByteBuffer const* self)
</code></p>

<p>Get the size of this Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The size of this Byte buffer.</p>

<h6><b>Remarks</b></h6>
<p> The size of a Byte buffer is the length of the Byte sequence it contains.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-getat">getat</h5>
<p><code>
R_Natural8Value R_ByteBuffer_getAt(R_ByteBuffer const* self, R_SizeValue index)
</code></p>

<p>Get the Byte value at the specified index.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>R_SizeValue index</td><td>The index. Must be within the bounds <code>[0,n)</code> where <code>n</code> is the size of this Byte buffer.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The Byte value.</p>

<h6><b>Remarks</b></h6>
<p> The size of a Byte buffer is the length of the Byte sequence it contains.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-isempty">isEmpty</h5>
<p><code>
R_BooleanValue R_ByteBuffer_isEmpty(R_ByteBuffer* self)
</code></p>

<p>Get if this Byte buffer is empty.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p><code>R_BooleanValue_True</code> if this Byte buffer is empty. <code>R_BooleanValue_False</code> otherwise.</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>self</code> is a null pointer.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-bytebuffer-swap">swap</h5>
<p><code>
void R_ByteBuffer_swap(R_ByteBuffer* self, R_ByteBuffer* other)
</code></p>

<p>Swap the contents of this Byte buffer with the contents of another Byte buffer.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to this Byte buffer.</td></tr>
  <tr><td>R_ByteBuffer* self</td><td>A pointer to the other Byte buffer.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>self</code> is a null pointer.</td></tr>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>other</code> is a null pointer.</td></tr>
</table>

<h4 id="r-filehandle">File Handle</h4>
<p>
<code>R_FileHandle</code> represents a operating system file handle.
This type is allocated on the heap and values of this type are referenced by <code>R_FileHandle</code> pointers.
A <code>R_FileHandle</code> pointer can be safely cast into a <code>R_ObjectReferenceValue</code> values.
An <code>R_ObjectReferenceValue</code> pointing to a <code>R_FileHandle</code> value can be safely cast into a <code>R_FileHandle</code> pointer.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-create">create</h5>

<p><code>
R_FileHandle* R_FileHandle_create(R_FileSystem* fileSystem)
</code></p>

<p>Create a file handle. The file handle is closed.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileSystem* self</td><td>A pointer to the backing <code>R_FileSystem</code> object.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>A pointer to the file handle.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-close">close</h5>
<p><code>
void R_FileHandle_close(R_FileHandle* self)
</code></p>

<p>Close this file handle.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle* self</td><td>A pointer to this file handle.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-openforreading">openForReading</h5>
<p><code>
void R_FileHandle_openForReading(R_FileHandle* self, R_FilePath* path)
</code></p>

<p>Open a file for reading. If the file is open, it is closed before trying to re-open it.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle* self</td><td>A pointer to this file handle.</td></tr>
  <tr><td>R_FilePath* path  </td><td>The file path of the file to read from.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>self</code> is a null pointer.</td></tr>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>path</code> is a null pointer.</td></tr>
  <tr><td>R_Status_FileSystemOperationFailed</td><td>Opening the file failed.            </td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-openforwriting">openForWriting</h5>
<p><code>
void R_FileHandle_openForWriting(R_FileHandle* self, R_FilePath* path)
</code></p>

<p>Open a file for writing. If the file is open, it is closed before trying to re-open it.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle* self</td><td>A pointer to this file handle.</td></tr>
  <tr><td>R_FilePath* path  </td><td>The file path of the file to write to.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>self</code> is a null pointer.</td></tr>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>path</code> is a null pointer.</td></tr>
  <tr><td>R_Status_FileSystemOperationFailed</td><td>Opening the file failed.            </td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-isclosed">isClosed</h5>
<p><code>
R_BooleanValue R_FileHandle_isClosed(R_FileHandle const* self)
</code></p>

<p>Get if this file handle is closed.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle const* self </td><td>A pointer to this file handle.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-isopened">isOpened</h5>
<p><code>
R_BooleanValue R_FileHandle_isOpened(R_FileHandle const* self)
</code></p>

<p>Get if this file handle is opened.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle const* self </td><td>A pointer to this file handle.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-isopenedforreading">isOpenedForReading</h5>
<p><code>
R_BooleanValue R_FileHandle_isOpenedForReading(R_FileHandle const* self)
</code></p>

<p>Get if this file handle is opened for reading.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle const* self </td><td>A pointer to this file handle.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-isopenedforwriting">isOpenedForWriting</h5>
<p><code>
R_BooleanValue R_FileHandle_isOpenedForWriting(R_FileHandle const* self)
</code></p>

<p>Get if this file handle is opened for writing.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle const* self </td><td>A pointer to this file handle.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-write">write</h5>
<p><code>
void R_FileHandle_write(R_FileHandle* self, void const* p, R_SizeValue bytesToWrite)
</code></p>

<p>Write Bytes to this file handle.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle* self       </td><td>A pointer to this file handle.</td></tr>
  <tr><td>void const* bytes        </td><td>A pointer to an array of <code>bytesToWrite</code> Bytes.</td></tr>
  <tr><td>R_SizeValue bytesToWrite </td><td>The number of Bytes in the array pointed to by <code>bytes</code>.</td></tr>
  <tr><td>R_SizeValue* bytesWritten</td><td>A pointer to a <code>R_SizeValue</code> variable.</td></tr>
</table>

<h6><b>Success</b></h6>
<p>
On success <code>*bytesWritten</code> is assigned the actual number of Bytes written.
</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>self</code> is a null pointer. </td></tr>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>bytes</code> is a null pointer.</td></tr>
  <tr><td>R_Status_OperationInvalid         </td><td>The file is not opened for writing.</td></tr>
  <tr><td>R_Status_FileSystemOperationFailed</td><td>Writing failed.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filehandle-read">read</h5>
<p><code>
void R_FileHandle_read(R_FileHandle* self, void const* bytes, R_SizeValue bytesToRead, R_SizeValue* bytesRead)
</code></p>

<p>Read Bytes from this file handle.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FileHandle* self      </td><td>A pointer to this file handle.</td></tr>
  <tr><td>void const* bytes       </td><td>A pointer to an array of <code>bytesToWrite</code> Bytes.</td></tr>
  <tr><td>R_SizeValue bytesToRead </td><td>The number of Bytes to read from the the array pointed to by <code>bytes</code>.</td></tr>
  <tr><td>R_SizeValue* bytesRead  </td><td>A pointer to a <code>R_SizeValue</code> variable.</td></tr>
</table>

<h6><b>Success</b></h6>
<p>
On success <code>*bytesRead</code> is assigned the actual number of Bytes read.
The number of Bytes read is 0 if the end of the file was reached.
</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>self</code> is a null pointer.</td></tr>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>bytes</code> is a null pointer.</td></tr>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>bytesRead</code> is a null pointer.</td></tr>
  <tr><td>R_Status_OperationInvalid         </td><td>The file is not opened for writing.</td></tr>
  <tr><td>R_Status_FileSystemOperationFailed</td><td>Writing failed.</td></tr>
</table>

<h4 id="r-filepath">File Path</h4>
<p>
<code>R_FilePath</code> represents a file path.
This type is allocated on the heap and values of this type are referenced by <code>R_FilePath</code> pointers.
A <code>R_FilePath</code> pointer can be safely cast into a <code>R_ObjectReferenceValue</code> values.
An <code>R_ObjectReferenceValue</code> pointing to a <code>R_FilePath</code> value can be safely cast into a <code>R_FilePath</code> pointer.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filepath-create">create</h5>

<p><code>
R_FilePath* R_Path_create()
</code></p>

<p>Create the empty file path.</p>

<h6><b>Return Value</b></h6>
<p>A pointer to the file path.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filepath-parsewindows">parseWindows</h5>
<p><code>
R_FilePath* R_FilePath_parseWindows(void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Parse a file path in the Windows format.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>bytes</td><td>A pointer to an array of <code>numberOfBytes</code> Bytes.</td></tr>
  <tr><td>numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>bytes</code> Bytes.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>A pointer to the file path.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filepath-parseunix">parseUnix</h5>
<p><code>
R_FilePath* R_FilePath_parseUnix(void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Parse a file path in the Unix format.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>bytes</td><td>A pointer to an array of <code>numberOfBytes</code> Bytes.</td></tr>
  <tr><td>numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>bytes</code> Bytes.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>A pointer to the file path.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filepath-parsenative">parseNative</h5>
<p><code>
R_FilePath* R_FilePath_parseNative(void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Parse a file path in the native format.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>bytes</td><td>A pointer to an array of <code>numberOfBytes</code> Bytes.</td></tr>
  <tr><td>numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>bytes</code> Bytes.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>A pointer to the file path.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filepath-tonative">toNative</h5>
<p><code>
R_String* R_FilePath_toNative(R_FilePath* self)
</code></p>

<p>Convert a file path to the native format.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>self</td><td>A pointer to this file path.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>A pointer to the string.</p>

<h4 id="r-filesystem">FileSystem</h4>
<p>
<code>R_FileSystem</code> provides access to the file system.
This type is allocated on the heap and values of this type are referenced by <code>R_String</code> pointers.
A <code>R_FileSystem</code> pointer can be safely cast into a <code>R_ObjectReferenceValue</code> values.
An <code>R_ObjectReferenceValue</code> pointing to a <code>R_String</code> value can be safely cast into a <code>R_String</code> pointer.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-filesystem-create">R_FileSystem_create</h5>
<p><code>
R_FileSystem* R_FileSystem_create()
</code></p>

<p>Create a file system.</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_AllocationFailed</td><td>An allocation failed.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-filesystem-getfilecontents">getFileContents</h5>
<p><code>
R_ByteBuffer* R_ByteBuffer_getFileContents(R_FilePath *path)
</code></p>

<p>Get the contents of a file.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td><a href="#">R_FilePath</a>* path</td><td>The file path of the file.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
A pointer to a <code>R_ByteBuffer</code> object with the file contents.
</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td><a href="#">R_Status_ArgumentValueInvalid</a></td><td><code>path</code> is a null pointer.</td></tr>
  <tr><td>R_Status_FileSystemOperationFailed</td><td>Opening the file failed.            </td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-filesystem-setfilecontents">setFileContents</h5>
<p><code>
void R_FileSystem_setFileContents(R_FilePath* path, R_ByteBuffer* contents)
</code></p>

<p>Get if a sequence of Bytes is a prefix of this string's sequence of Bytes.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_FilePath* path</td><td>The file path of the file.</td></tr>
  <tr><td>R_ByteBuffer const* byteBuffer</td><td>A poiner to the Byte buffer with the file contents.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>path</code> is a null pointer.    </td></tr>
  <tr><td>R_Status_ArgumentValueInvalid     </td><td><code>contents</code> is a null pointer.</td></tr>
  <tr><td>R_Status_FileSystemOperationFailed</td><td>Opening the file failed.                </td></tr>
</table>

<h4 id="r-list">List</h4>
<p>
<code>R_List</code> represents a list of <code>R_Value</code> objects.
This type is allocated on the heap and values of this type are referenced by <code>R_List</code> pointers.
A <code>R_List</code> pointer can be safely cast into a <code>R_ObjectReferenceValue</code> values.
An <code>R_ObjectReferenceValue</code> pointing to a <code>R_List</code> value can be safely cast into a <code>R_List</code> pointer.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-list-create">R_List_create</h5>
<p><code>
R_List* R_List_create()
</code></p>

<p>Create a list.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>bytes        </td><td>A pointer to an array of Bytes.</td></tr>
  <tr><td>numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>bytes</code>.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>bytes</code> is a null pointer.</td></tr>
  <tr><td>R_Status_EncodingInvalid     </td><td>The sequence of Bytes does not represented a UTF-8-NO-BOM string.</td></tr>
</table>

<h6><b>Return value</b></h6>
<p>A pointer to the <code>R_List</code> value.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-list-append">append</h5>
<p><code>
void R_List_append(R_List* self, R_Value value)
</code></p>

<p>Append a <code>R_Value</code> to a list.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_List* self           </td><td>A pointer to this list.</td></tr>
  <tr><td>R_Value value          </td><td>The value to append.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-list-clear">clear</h5>
<p><code>
void R_List_clear(R_List* self)
</code></p>

<p>Clear this list.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_List* self</td><td>A pointer to this list.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-list-getat">getAt</h5>
<p><code>
R_Value R_List_getAt(R_List* self, R_SizeValue index)
</code></p>

<p>Get the value at the specifie index in this list.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_List* self</td><td>A pointer to this list.</td></tr>
  <tr><td>R_SizeValue index</td><td>The index. Must be within the bounds <code>[0,n)</code> where <code>n</code> is the size of this list.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The value.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-list-getsize">getSize</h5>
<p><code>
R_SizeValue R_List_getSize(R_List const* self)
</code></p>

<p>Get the size of this list.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_List* self</td><td>A pointer to this list.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The size of this list.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-list-insertat">insert</h5>
<p><code>
void R_List_insertAt(R_List* self, R_SizeValue index, R_Value value)
</code></p>

<p>Compare this string with another string for equality.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_List* self      </td><td>A pointer to this list.</td></tr>
  <tr><td>R_SizeValue index </td><td>The index at which to insert the value. Must be within the bounds of <code>[0,n]</code> where <code>n</code> is the size of thie list.</td></tr>
  <tr><td>R_Value value     </td><td>The value to insert.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-list-isempty">isEmpty</h5>
<p><code>
R_BooleanValue R_List_isEmpty(R_List* self)
</code></p>

<p>Get if this list is empty.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_List* self</td><td>A pointer to this list.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p><code>R_BooleanValue_True</code> if this list is empty. <code>R_BooleanValue_False</code> otherwise.</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>self</code> is a null pointer.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-list-prepend">prepend</h5>
<p><code>
void R_List_prepend(R_List* self, R_Value value)
</code></p>

<p>Get if a sequence of Bytes is a prefix of this string's sequence of Bytes.</p>

<p>Prepend a <code>R_Value</code> to a list.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_List* self           </td><td>A pointer to this list.</td></tr>
  <tr><td>R_Value value          </td><td>The value to prepend.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-list-remove">remove</h5>
<p><code>
void R_List_remove(R_List* self, R_SizeValue index, R_SizeValue count)
</code></p>

<p>Remove <code>length</code> elements starting with element at index <code>index</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_List* self</td><td>A pointer to this list.</td></tr>
  <tr><td>R_SizeValue index</td><td>The index of the first element to remove.</td></tr>
  <tr><td>R_SizeValue length</td><td>The number of elements to remove.</td></tr>
</table>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>self</code> is a null pointer.</td></tr>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>index + count > n</code> where <code>n</code> is the length of the list.</td></tr>
</table>

<h4 id="r-stack">Stack</h4>
<p>
<code>R_Stack</code> represents a stack of <code>R_Value</code> objects.
This type is allocated on the heap and values of this type are referenced by <code>R_Stack</code> pointers.
A <code>R_Stack</code> pointer can be safely cast into a <code>R_ObjectReferenceValue</code> values.
An <code>R_ObjectReferenceValue</code> pointing to a <code>R_Stack</code> value can be safely cast into a <code>R_Stack</code> pointer.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-stack-create">R_Stack_create</h5>
<p><code>
R_Stack* R_Stack_create()
</code></p>

<p>Create a stack.</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>bytes</code> is a null pointer.</td></tr>
  <tr><td>R_Status_EncodingInvalid     </td><td>The sequence of Bytes does not represented a UTF-8-NO-BOM string.</td></tr>
</table>

<h6><b>Return value</b></h6>
<p>A pointer to the <code>R_Stack</code> value.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-stack-clear">clear</h5>
<p><code>
void R_Stack_clear(R_Stack* self)
</code></p>

<p>Clear this stack.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_Stack* self</td><td>A pointer to this stack.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-stack-getsize">getSize</h5>
<p><code>
R_SizeValue R_Stack_getSize(R_Stack const* self)
</code></p>

<p>Get the size of this stack.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_Stack* self</td><td>A pointer to this stack.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The size of this stack.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-stack-isempty">isEmpty</h5>
<p><code>
R_BooleanValue R_Stack_isEmpty(R_Stack* self)
</code></p>

<p>Get if this stack is empty.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_Stack* self</td><td>A pointer to this stack.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p><code>R_BooleanValue_True</code> if this stack is empty. <code>R_BooleanValue_False</code> otherwise.</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>self</code> is a null pointer.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-stack-peek">peek</h5>
<p><code>
R_Value R_Stack_peek(R_Stack* self)
</code></p>

<p>Peek at the value on top of this stack.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_Stack self </td><td>A pointer to this stack.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The value.</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-stack-pop">pop</h5>
<p><code>
R_Value R_Stack_pop(R_Stack* self)
</code></p>

<p>Pop the value from the top of this stack.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_Stack self </td><td>A pointer to this stack.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The value.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-stack-push">push</h5>
<p><code>
void R_Stack_push(R_Stack* self, R_Value value)
</code></p>

<p>Push a value on the top of this stack.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_Stack* self            </td><td>A pointer to this stack.</td></tr>
  <tr><td>R_Value value            </td><td>The value to push.</td></tr>
</table>

<h4 id="r-string">String</h4>
<p>
<code>R_String</code> represents an Unicode string encoded as UTF-8-NO-BOM.
This type is allocated on the heap and values of this type are referenced by <code>R_String</code> pointers.
A <code>R_String</code> pointer can be safely cast into a <code>R_ObjectReferenceValue</code> values.
An <code>R_ObjectReferenceValue</code> pointing to a <code>R_String</code> value can be safely cast into a <code>R_String</code> pointer.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-create-pn">R_String_create_pn</h5>
<p><code>
R_String* R_String_create_pn(R_ImmutableByteArray* immutableByteArray)
</code></p>

<p>Create a string from an immutable Byte array.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>immutableByteArray</td><td>A pointer to an immutable Byte array</td></tr>
</table>

<h6><b>Return value</b></h6>
<p>A pointer to the string.</p>

<h6><b>Errors</b></h6>
<table>
  <tr><td>R_Status_ArgumentValueInvalid</td><td><code>immutableByteArray</code> is a null pointer.</td></tr>
  <tr><td>R_Status_EncodingInvalid     </td><td>The sequence of Bytes does not represented a UTF-8-NO-BOM string.</td></tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-create">R_String_create</h5>
<p><code>
R_String* R_String_create_pn(R_Value value)
</code></p>

<p>
Create a string from a value.
</p>

<p>
The specified value may contain a R_ByteBuffer object.
In that case, the string is created from the Bytes of the Byte buffer object.
A <code>R_Status_EncodingInvalid</code> is raised if the Byte sequence of that <code>R_ByteBuffer</code> object is not a UTF8 Byte sequence.
</p>

<p>
The specified value may contain a R_String object.
In that case, the string is created from the R_String object.
</p>

<p>
The specified value may contain a R_StringBuffer object.
In that case, the string is created from the R_StringBuffer object.
</p>

<p>
The specified value may contain a R_ImmutableByteArray object.
In that case, the string is created from the R_ImmutableByteArray object.
</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>value        </td><td>The value.</td></tr>
</table>

<h6><b>Return value</b></h6>
<p>A pointer to the string. </p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td>The value does not contain either a <code>R_ByteBuffer</code> object, a <code>R_String</code> object, or a <code>R_StringBuffer</code> object.</td>
  </tr>
  <tr>
    <td>R_Status_EncodingInvalid    </td>
    <td>The value contains a <code>R_ByteBuffer</code> object. However, the Byte sequence of that <code>R_ByteBuffer</code> object is not a UTF8 Byte sequence.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-string-endswith-pn">endsWith_pn</h5>
<p><code>
R_BooleanValue R_String_endsWith_pn(R_String const* self, void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Get if a sequence of Bytes is a suffix of this string's sequence of Bytes.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self           </td><td>A pointer to this string.</td></tr>
  <tr><td>void const* bytes        </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
<code>R_BooleanValue_True</code> if the sequence of Bytes is a suffix of this string's sequence of Bytes.
<code>R_BooleanValue_False</code> otherwise.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h5 id="r-string-startswith-pn">startsWith_pn</h5>
<p><code>
R_BooleanValue R_String_startsWith_pn(R_String const* self, void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Get if a sequence of Bytes is a prefix of this string's sequence of Bytes.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self           </td><td>A pointer to this string.</td></tr>
  <tr><td>void const* bytes        </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
<code>R_BooleanValue_True</code> if the sequence of Bytes is a prefix of this string's sequence of Bytes.
<code>R_BooleanValue_False</code> otherwise.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-isequalto">isEqualTo</h5>
<p><code>
R_BooleanValue R_String_isEqualTo(R_String const* self, R_String const* other)
</code></p>

<p>Compare this string with another string for equality.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String const* self </td><td>A pointer to this string.</td></tr>
  <tr><td>R_String const* other</td><td>A pointer to the other string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
<code>R_BooleanValue_True</code> if this string is equal to the other string.
<code>R_BooleanValue_False</code> otherwise.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-isequalto_pn">isEqualTo_pn</h5>
<p><code>
R_BooleanValue R_String_isEqualTo_pn(R_String const* self, void const* bytes, R_SizeValue numberOfBytes)
</code></p>

<p>Get if a sequence of Bytes is this string's sequence of Bytes.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self           </td><td>A pointer to this string.</td></tr>
  <tr><td>void const* bytes        </td><td>A pointer to an array of <code>n</code> Bytes.</td></tr>
  <tr><td>R_SizeValue numberOfBytes</td><td>The number of Bytes in the array pointed to by <code>p</code>.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>
<code>R_BooleanValue_True</code> if the sequence of Bytes is this string's sequence of Bytes.
<code>R_BooleanValue_False</code> otherwise.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-getnumberofbytes">getNumberOfBytes</h5>
<p><code>
R_SizeValue R_String_getNumberOfBytes(R_String const* self)
</code></p>

<p>Get the size, in Bytes, of this string.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The size, in Bytes, of this string.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-getbyteat">getByteAt</h5>
<p><code>
R_Natural8Value R_String_getByteAt(R_String const* self, R_SizeValue index)
</code></p>

<p>Get the Byte value at the specified index.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
  <tr><td>R_SizeValue index</td><td>The index. Must be within the bounds <code>[0,n)</code> where <code>n</code> is the size, in Bytes, of this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The Byte value.</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-toboolean">toBoolean</h5>
<p><code>
R_BooleanValue R_String_toBoolean(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as boolean literal and convert the boolean represented by that literal into an <code>R_BooleanValue</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The boolean value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a boolean literal. Valid boolean literals are <code>true</code> and <code>false</code>, both case sensitve.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-tointeger16">toInteger16</h5>
<p><code>
R_Integer16Value R_String_toInteger16(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as decimal integer literal and convert the number represented by that integer literal into an <code>R_Integer16Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The integer value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal integer literal or
    the number represented by the literal cannot be represented a value of type <code>R_Integer16Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-tointeger32">toInteger32</h5>
<p><code>
R_Integer32Value R_String_toInteger32(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as decimal integer literal and convert the number represented by that literal into an <code>R_Integer32Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The integer value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal integer literal or
    the number represented by the literal cannot be represented a value of type <code>R_Integer32Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-tointeger64">toInteger64</h5>
<p><code>
R_Integer64Value R_String_toInteger64(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as decimal integer literal and convert the number represented by that literal into an <code>R_Integer64Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The integer value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal integer literal or
    the number represented by the literal cannot be represented a value of type <code>R_Integer64Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-tointeger8">toInteger8</h5>
<p><code>
R_Integer8Value R_String_toInteger8(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as decimal integer literal and convert the number represented by that literal into an <code>R_Integer8Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The integer value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal integer literal or
    the number represented by the integer literal cannot be represented a value of type <code>R_Integer8Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-tonatural16">toNatural16</h5>
<p><code>
R_Natural16Value R_String_toNatural16(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as decimal natural literal and convert the number represented by that literal into an <code>R_Natural16Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The natural value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal natural literal or
    the number represented by the literal cannot be represented a value of type <code>R_Natural16Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-tonatural32">toNatural32</h5>
<p><code>
R_Natural32Value R_String_toNatural16(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as decimal natural literal and convert the number represented by that literal into an <code>R_Natural32Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The natural value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal natural literal or
    the number represented by the literal cannot be represented a value of type <code>R_Natural32Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-tonatural64">toNatural64</h5>
<p><code>
R_Natural64Value R_String_toNatural16(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as a decimal natural literal and convert the number represented by that literal into an <code>R_Natural64Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The natural value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal natural literal or
    the number represented by the literal cannot be represented a value of type <code>R_Natural64Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-tonatural8">toNatural8</h5>
<p><code>
R_Natural8Value R_String_toNatural8(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as a decimal natural literal and convert the number represented by that literal into an <code>R_Natural8Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The natural value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal natural literal or
    the number represented by the literal cannot be represented a value of type <code>R_Natural8Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-toreal32">toReal32</h5>
<p><code>
R_Real32Value R_String_toReal32(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as a decimal real literal and convert the number represented by that literal into an <code>R_Real32Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The <code>R_Real32Value</code> value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal real literal or
    the number represented by the literal cannot be represented a value of type <code>R_Real32Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h5 id="r-string-toreal64">toReal64</h5>
<p><code>
R_Real64Value R_String_toReal64(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as a decimal real literal and convert the number represented by that literal into an <code>R_Real64Value</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The <code>R_Real64Value</code> value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a decimal real literal or
    the number represented by the literal cannot be represented a value of type <code>R_Real64Value</code>.</td>
  </tr>
</table>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<p><code>
R_VoidValue R_String_toVoid(R_String const* self)
</code></p>

<p>Interprete the symbols of this string as a void literal and convert the void value represented by that literal into an <code>R_VoidValue</code>.</p>

<h6><b>Parameters</b></h6>
<table>
  <tr><td>R_String* self</td><td>A pointer to this string.</td></tr>
</table>

<h6><b>Return Value</b></h6>
<p>The void value.</p>

<h6><b>Errors</b></h6>
<table>
  <tr>
    <td>R_Status_ArgumentTypeInvalid</td>
    <td><code>self</code> is a null pointer.</td>
  </tr>
  <tr>
    <td>R_Status_ConversionFailed</td>
    <td>The symbols of this string cannot be interpreted as a void literal. The valid void literal is <code>void</code>, case sensitve.</td>
  </tr>
</table>

  </div>
  <div class="right-column">
  </div>
  </main>
  <footer>
    <span style="font-style: italic">Webite maintained by Michael Heilmann. Last modified on 6 October 2024.</span>
  </footer>
  </body>
</html>

